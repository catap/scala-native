package scala.scalanative
package runtime

import scala.scalanative.unsafe._
import scala.scalanative.unsigned._

import org.junit.Test
import org.junit.Assert._

import scalanative.junit.utils.MultiThreadHelper._

class AtomicSuite {

%{
   classes = ['Byte', 'Short', 'Int', 'Long',
            'UnsignedByte', 'UnsignedShort', 'UnsignedInt',
             'UnsignedLong', 'CSize']

   types = ['Byte', 'CShort', 'CInt', 'CLong',
            'Byte', 'CUnsignedShort', 'CUnsignedInt', 'CUnsignedLong',
            'CSize']

   companionObjects = ['Byte', 'CShort', 'CInt', 'CLong',
                       'Byte', 'UShort', 'UInt', 'ULong',
                       'CSize']

   names = ['byte', 'short', 'int', 'long',
            'ubyte', 'ushort', 'uint', 'ulong', 'csize']
}%

% for (C, O, T, N) in zip(classes, companionObjects, types, names):
%{
   default = '0' if N in ['int'] else '0.asInstanceOf['+T+']'
   cast = '' if N == 'int' else '.asInstanceOf['+T+']'

   if N in ['int','byte','short','ubyte']:
       defaultCounter = '0'
       counterT = 'Int'
   elif N in ['ushort']:
       defaultCounter = '0.asInstanceOf[CUnsignedInt]'
       counterT = 'UInt'
   else:
       defaultCounter = '0.asInstanceOf['+T+']'
       counterT = T
}%
% for cmp in ['Strong', 'Weak']:

  @Test def `compare and swap ${cmp} ${N}`(): Unit = {
    val a = CAtomic${C}()

    val b = 3${cast}

    assertFalse(a.compareAndSwap${cmp}(1${cast}, 3${cast})._1)

    assert(a.compareAndSwap${cmp}(${default}, 3${cast})._2 == 3${cast})

    a.free()
  }
% end

@Test def `compare_and_swap (weak and strong) is atomic for ${N}`(): Unit = {

    val numThreads = 2
    testWithMinRepetitions() { n: Int =>
      var number = ${defaultCounter}
      withThreads(numThreads, label = "CounterExample") { _: Int =>
        @inline def badCaS(expectedValue: ${counterT}, newValue: ${counterT}): ${counterT} = {
          val oldValue = number
          if (number == expectedValue) {
            number = newValue
          }
          oldValue
        }

        var i = n
        val b = 1${cast}
        // making this as fast as possible
        while (i > 0) {
          var newValue = ${defaultCounter}
          var expected = ${defaultCounter}
          do {
            expected = number
            newValue = expected + b
          } while (badCaS(expected, newValue) != expected)
          i -= 1
        }
      }
      number != (n * numThreads)${cast}
    } { n: Int =>
% for cmp in ['Strong', 'Weak']:
      {
      val number = CAtomic${C}()
      withThreads(numThreads, label = "Test") { _: Int =>
        var i = n
        val b = 1${cast}
        // making this as fast as possible
        while (i > 0) {
          var newValue = 0${cast}
          var expected = 0${cast}
          do {
            expected = number.load()
%   if N == 'ushort':
            newValue = (expected + b).toUShort
%   else:
            newValue = (expected + b)${cast}
%   end
          } while (!number.compareAndSwap${cmp}(expected, newValue)._1)
          i -= 1
        }
      }

      val value    = number.load()
      val expected = (n * numThreads)${cast}
      number.free()
      assertEquals(value, expected)
      }
% end
      true
    }
  }

  @Test def `load and store ${N}`(): Unit = {
    val a = CAtomic${C}()

    val b = 1${cast}

    assert(a.load() == ${default})

    a.store(b)

    assert(a.load() == b)

    a.free()
  }

  @Test def `fetch_add ${N}`(): Unit = {
    val a = CAtomic${C}()

    val b = 1${cast}

    assert(a.fetchAdd(b) == ${default})

    assert(a.load() == b)

    a.free()
  }

  @Test def `add_fetch ${N}`(): Unit = {
    val a = CAtomic${C}()

    val b = 1${cast}

    assert(a.addFetch(b) == b)

    assert(a.load() == b)

    a.free()
  }

    @Test def `fetch_add, add_fetch, fetch_sub, sub_fetch are atomic for ${N}`(): Unit = {
        val numThreads = 2
        testWithMinRepetitions() {
          n: Int =>
            var number = ${defaultCounter}
            withThreads(numThreads, label = "CounterExample") {_: Int =>
              var i = n
              val b = 1${cast}
              // making this as fast as possible
              while (i > 0) {
                number  = number + b
                i -= 1
              }
            }
            number != (n * numThreads)${cast}
        } {
          n: Int =>
% for op in ['fetchAdd', 'addFetch']:
            {
            val number = CAtomic${C}()
            withThreads(numThreads, label = "Test") {_: Int =>
              var i = n
              val b = 1${cast}
              // making this as fast as possible
              while (i > 0) {
                number.${op}(b)
                i -= 1
              }
            }

            val value = number.load()
            val expected = (n * numThreads)${cast}
            number.free()
            assertEquals(value, expected)
            }
% end
% for op in ['fetchSub', 'subFetch']:
% minusOne = '-1'+cast if N in ['byte', 'ubyte', 'short', 'int', 'long', 'csize'] else O+'.MaxValue'
            {
            val number = CAtomic${C}()
            withThreads(numThreads, label = "Test") {_: Int =>
              var i = n
              val b = ${minusOne}
              // making this as fast as possible
              while (i > 0) {
                number.${op}(b)
                i -= 1
              }
            }

            val value = number.load()
            val expected = (n * numThreads)${cast}
            number.free()
            assertEquals(value, expected)
            }
% end
            true
        }
      }

  @Test def `fetch_sub ${N}`(): Unit = {
    val a = CAtomic${C}(1${cast})

    val b = 1${cast}

    assert(a.fetchSub(b) == b)

    assert(a.load() == ${default})

    a.free()
  }

  @Test def `sub_fetch ${N}`(): Unit = {
    val a = CAtomic${C}(1${cast})

    val b = 1${cast}

    assert(a.subFetch(b) == ${default})

    assert(a.load() == ${default})

    a.free()
  }

  @Test def `fetch_and ${N}`(): Unit = {
    val a = CAtomic${C}()

    val b = 1${cast}

    assert(a.fetchAnd(b) == ${default})

    assert(a.load() == ${default})

    a.free()
  }

  @Test def `and_fetch ${N}`(): Unit = {
    val a = CAtomic${C}()

    val b = 1${cast}

    assert(a.andFetch(b) == ${default})

    assert(a.load() == ${default})

    a.free()
  }

  @Test def `fetch_or ${N}`(): Unit = {
    val a = CAtomic${C}()

    val b = 1${cast}

    assert(a.fetchOr(b) == ${default})

    assert(a.load() == b)

    a.free()
  }

  @Test def `or_fetch ${N}`(): Unit = {
    val a = CAtomic${C}()

    val b = 1${cast}

    assert(a.orFetch(b) == b)

    assert(a.load() == b)

    a.free()
  }

  @Test def `fetch_xor ${N}`(): Unit = {
    val a = CAtomic${C}(1${cast})

    val b = 1${cast}

    assert(a.fetchXor(b) == 1${cast})

    assert(a.load() == ${default})

    a.free()
  }

  @Test def `xor_fetch ${N}`(): Unit = {
    val a = CAtomic${C}(1${cast})

    val b = 1${cast}

    assert(a.xorFetch(b) == ${default})

    assert(a.load() == ${default})

    a.free()
  }
% end

% for N in ['Char', 'UnsignedChar']:
% for cmp in ['Strong', 'Weak']:
% cast = '.asInstanceOf[C'+N+']'

  @Test def `compare and swap ${cmp} ${N}`(): Unit = {
    val a = CAtomic${N}()

    val b = 'b'${cast}

    assertFalse(a.compareAndSwap${cmp}('b'${cast}, 'b'${cast})._1)

    assert(a.compareAndSwap${cmp}('a'${cast}, 'b'${cast})._2 == 'b'${cast})

    a.free()
  }
% end
% end

  @Test def `multiple compare and swap should yield correct results`(): Unit = {
    val a = CAtomicInt()

    var i = 0

    while(i < 10) {
        assert(a.compareAndSwapStrong(i, i + 1)._2 == i + 1)
        i += 1
    }

    assert(a.load() == 10)

    a.free()
  }

  @Test def `store behaves as expected`(): Unit = {
    val a = CAtomicInt()

    a.store(1)

    assert(a.load() == 1)

    a.free()
  }

  @Test def `constructor with initial value`(): Unit = {
    val a = CAtomicLong(2.toLong)

    assert(a.load() == 2.toLong)

    a.free()
  }

}
